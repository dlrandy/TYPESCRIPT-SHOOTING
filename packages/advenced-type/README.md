类型系统不仅有表达性，还要易于使用，使得类型的限制和关联简单，
简洁且可推导

subtype vs super type
比如有两个类型A，B，B是A的子类型，也就是B包含于A，那么任何能用A的地方，都可以安全的
使用B。

any是任何类型的超类；never是任何类型的子类。

泛型如何判断子类型？
对象如何判断子类型？
函数如何判断子类型？

A>:B A是B的超类或者同类；
A<:B A是B的子类或者同类。

子类型规则在复杂的类型上表现的不一致

typescript 不是设计来绝对安全的，它的类型系统是要在捕获实际的错误和易于使用之间
到达一个平衡。所以ts允许父类所在的地方可以放上子类

typescript的行为：对于一个shape(对象、类)，可以传递一个类型--属性类型<:期待的类型，
也就是期待类型的子类型，而不能是超类型

如果对象A可以分配给对象B，那么A的属性类型必须<:(小于等于)B对应类型


在typescript里，每一个复杂类型的成员都是<:----objects,class,arrays以及函数的返回值；
但是例外的是函数的参数>:的。

函数A是函数B的子类型的条件是：
1，A有同等数量或者更少数量的参数
2，A的this的类型要么不指定，要么大于等于>:B的this类型
3，A的每个参数>:B对应的参数
4，A的返回类型<:B的返回类型
